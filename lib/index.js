// Generated by CoffeeScript 1.10.0
var qs, web3,
  slice = [].slice;

qs = require('querystring');

if ((typeof window !== "undefined" && window !== null ? window.web3 : void 0) != null) {
  if (typeof window.web3 === 'undefined') {
    web3 = new Web3(window.web3.currentProvider);
    window.web3 = web3;
  }
} else {
  console.log('Warning: no web3 exists in the window... :(');
}

exports.parseFunctionSignature = function(fn_string) {
  var args, inputs, name;
  name = fn_string.split('(')[0];
  args = fn_string.split('(')[1].slice(0, -1);
  inputs = args.split(', ').map(function(a) {
    var ref, type, value;
    ref = a.split(' '), type = ref[0], value = ref[1];
    return {
      type: type,
      value: value
    };
  });
  return {
    name: name,
    inputs: inputs
  };
};

exports.parseProtocolUrl = function(url) {
  var address, input_types, path, protocol, q, query, ref, ref1, tx;
  ref = url.split('?'), path = ref[0], query = ref[1];
  ref1 = path.split(':'), protocol = ref1[0], address = ref1[1];
  q = qs.decode(query);
  if (q.fn != null) {
    input_types = {};
    Object.keys(query).map((function(_this) {
      return function(q_k) {
        var input_name, slugs;
        if (q_k.indexOf('input.') > -1) {
          slugs = q_k.split('.');
          if (slugs[2] === 'type') {

          } else if (input_name = slugs[1]) {
            return input_types[input_name] = query["input." + input_name + ".type"];
          }
        }
      };
    })(this));
    tx = {
      to: address,
      value: q.value,
      gas: q.gas,
      inputs: Object.keys(input_types).map(function(name) {
        return {
          name: name,
          type: input_types[name]
        };
      })
    };
  } else if (q["function"] != null) {
    parseFunctionSignature(q["function"]);
    tx = {
      to: address,
      value: q.value,
      gas: q.gas,
      inputs: parseFunctionSignature(q["function"])
    };
  } else if (q.data) {
    tx = {
      to: address,
      value: q.value,
      gas: q.gas,
      data: q.data
    };
  } else {
    tx = {
      to: address,
      value: q.value,
      gas: q.gas,
      from: q.from
    };
  }
  return tx;
};

exports.send = function(tx, cb) {
  var from, gas, to, value;
  to = tx.to, value = tx.value, from = tx.from, gas = tx.gas;
  value = Number(value);
  return window.web3.eth.sendTransaction({
    from: from || window.web3.eth.accounts[0],
    to: to,
    value: value,
    gas: gas
  }, cb);
};

exports.buildAPIWithABI = function(abi) {
  var _exports;
  _exports = {};
  abi.map(function(fn) {
    return _exports[fn.name] = function() {
      var _options, address, args, cb, i;
      address = arguments[0], args = 4 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 2) : (i = 1, []), _options = arguments[i++], cb = arguments[i++];
      console.log.apply(console, ['address'].concat(slice.call(args), [_options], [fn.name]));
      return window.web3.eth.contract(abi).at(address, function(err, Contract) {
        var options;
        options = Object.assign({}, {
          to: address,
          from: web3.eth.accounts[0],
          value: 0,
          gas: 10000
        }, _options);
        console.log('Submitting transaction w local web3 provider', options);
        return Contract[fn.name].apply(Contract, slice.call(args).concat([options], [cb]));
      });
    };
  });
  return _exports;
};

exports.execWithABI = function() {
  var abi, address, args, cb, fn, i, options_;
  abi = arguments[0], address = arguments[1], fn = arguments[2], args = 6 <= arguments.length ? slice.call(arguments, 3, i = arguments.length - 2) : (i = 3, []), options_ = arguments[i++], cb = arguments[i++];
  return window.web3.eth.contract(abi).at(address, function(err, Contract) {
    var options;
    options = Object.assign({}, {
      to: address,
      from: window.web3.eth.accounts[0],
      value: 0,
      gas: 100000
    }, options_);
    return Contract[fn].apply(Contract, slice.call(args).concat([options], [cb]));
  });
};
